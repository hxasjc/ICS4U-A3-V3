package hxasjc.ics4ua3v3;

import hxasjc.ics4ua3v3.monsters.Monster;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;

import java.util.function.Consumer;

import static hxasjc.ics4ua3v3.DiceRoll.rollD20;
import static hxasjc.ics4ua3v3.DiceRoll.rollDice;

/**
 * This class is responsible for running the battle itself
 */
@SuppressWarnings("FieldCanBeLocal")
public class MainBattle {
    /**
     * The UI controller associated with this battle
     */
    private final BattleController controller;

    /**
     * The class representing the player's monster
     */
    private final Class<? extends Monster> playerClass;

    /**
     * The class representing the computer's monster
     */
    private final Class<? extends Monster> computerClass;

    /**
     * The player's monster
     */
    private final Monster playerMonster;

    /**
     * The computer's monster
     */
    private final Monster computerMonster;

    /**
     * If the player's monster should go first. This is determined by {@link MainBattle#determineOrder()}
     */
    private boolean playerFirst = false;

    /**
     * A consumer to handle errors, allowing for them to be handled by the {@link BattleApp}
     */
    private Consumer<Throwable> errorConsumer = throwable -> {};

    /**
     * The current battle's transcript
     */
    private final BattleTranscript transcript = new BattleTranscript();

    /**
     * Creates a new battle instance. This creates the monsters themselves as well as initializing the final bits of UI
     * @param controller The UI controller associated with the battle
     * @param playerClass The player's monster class
     * @param computerClass The computer's monster class
     * @throws Throwable Throws any Throwable that get thrown
     */
    public MainBattle(BattleController controller, Class<? extends Monster> playerClass, Class<? extends Monster> computerClass) throws Throwable {
        this.controller = controller;
        this.playerClass = playerClass;
        this.computerClass = computerClass;

        playerMonster = playerClass.getDeclaredConstructor().newInstance(); //create monster objects
        computerMonster = computerClass.getDeclaredConstructor().newInstance();

        controller.setPlayerImage(playerMonster.getMonsterImage()); //set monster images
        controller.setComputerImage(computerMonster.getMonsterImage());

        controller.updateAbilityToolbar(playerMonster); //update ability buttons
        controller.setAbilityButtonConsumer(this::playerAbilityButtonHandler); //set consumer for ability buttons
        controller.updateMonsterLabels(playerMonster, computerMonster); //update labels naming the monsters
    }

    /**
     * Determine who goes first. Starts by rolling a D20 each. If they are tied, the program attepmts to break the tie using the monsters' dexterity score. If It's still tied, just roll a D100 each
     */
    public void determineOrder() {
        int playerInit = rollD20();
        int computerInit = rollD20();

        if (playerInit == computerInit) {
            int playerMod = playerMonster.getStat(StatRolls.DEX);
            int computerMod = computerMonster.getStat(StatRolls.DEX);

            if (playerMod == computerMod) {
                if (
                        rollDice(1, 100) >
                                rollDice(1, 100)
                ) {
                    playerFirst = true;
                }
            } else {
                if (playerMod > computerMod) {
                    playerFirst = true;
                }
            }
        } else {
            if (playerInit > computerInit) {
                playerFirst = true;
            }
        }

        controller.setPlayerInitiative(playerInit);
        controller.setComputerInitiative(computerInit);
    }

    /**
     * Starts the battle, beginning the first turn for either player or computer
     */
    public void startBattleLoop() {
        updateHealth();

        if (playerFirst) {
            startPlayerTurn();
        } else {
            computerTurn();
        }
    }

    /**
     * Start the player's turn, enabling the ability buttons
     */
    public void startPlayerTurn() {
        System.out.println("player turn");
        controller.disableAbilityToolbar(false);
    }

    /**
     * Handles the event from when an AbilityButton is pressed
     * @param event Event generated by JavaFX
     */
    public void playerAbilityButtonHandler(ActionEvent event) {
        try {
            AbilityButton button = (AbilityButton) event.getSource();
            Attack ability = button.getAttack();

            System.out.println("using ability '" + ability.getName() + "'");
            playerMonster.damageWithAttack(computerMonster, ability, transcript);

            controller.disableAbilityToolbar(true);
            if (!isAMonsterDead()) {
                computerTurn();
            } else {
                endGame(true);
            }
        } catch (ClassCastException ignored) {
        } catch (Throwable t) {
            errorConsumer.accept(t);
        }
    }

    /**
     * Computer uses its primary attack against the player
     */
    public void computerTurn() {
        System.out.println("computer turn");
        computerMonster.damageWithPrimary(playerMonster, transcript);
        updateHealth();
        if (!isAMonsterDead()) {
            startPlayerTurn();
        } else {
            endGame(false);
        }
    }

    /**
     * Displays a message at game end
     * @param playerWin Whether the player won the battle
     */
    public void endGame(boolean playerWin) {
        updateHealth();
        new Alert(
                Alert.AlertType.INFORMATION,
                playerWin ? "You Won!" : "You Lost"
        ).showAndWait();

        //TODO implement this better
        /*Optional<ButtonType> button = new Alert(
                Alert.AlertType.CONFIRMATION,
                "Would you like to save the battle transcript?"
        ).showAndWait();

        if (button.isPresent()) {
            if (button.get().getText().equals("OK")) {
                transcript.save(controller.abilityToolbar.getScene().getWindow());
            }
        }*/
    }

    /**
     * Update the health labels and bars of both monsters
     */
    private void updateHealth() {
        controller.setPlayerHealth(
                playerMonster.getHealth(),
                playerMonster.getMaxHealth()
        );
        controller.setComputerHealth(
                computerMonster.getHealth(),
                computerMonster.getMaxHealth()
        );
    }

    /**
     * Checks if a monster is dead
     * @return Whether a monster is dead
     */
    private boolean isAMonsterDead() {
        return playerMonster.getHealth() < 1 || computerMonster.getHealth() < 1;
    }

    /**
     * Sets the consumer for handling any errors
     * @param consumer Error handling consumer
     */
    public void setErrorHandler(Consumer<Throwable> consumer) {
        errorConsumer = consumer;
    }
}
